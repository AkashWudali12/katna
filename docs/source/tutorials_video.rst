.. _tutorials_video:

========================
How to Use Katna.video
========================

Extract keyframes for a video
----------------------------------------------------------------

**Step 1**

Import the video module 

.. code-block:: python

   from Katna.video import Video

**Step 2**

Instantiate the video class inside your main module (necessary for multiprocessing in windows)

.. code-block:: python

     if __name__ == "__main__":
          vd = Video()
   
**Step 3**

Call the **extract_video_keyframes** method.
The method accepts two parameters and returns a list of numpy 2D array which are images. 
Refer to API reference for further details. Below are the two parameters required by the method

1. **no_of_frames**: Number of key frames to be extracted

2. **file_path**: Video file path.


.. code-block:: python

     imgs = vd.extract_video_keyframes(no_of_frames = no_of_frames_to_return, \
     file_path= video_file_path)


**Step 4 (Optional)**

In case you want to persist the extracted key frames then call the **save_frame_to_disk** method.
The method accepts three parameters and returns nothing. 
Refer to API reference for further details. Below are the two parameters required by the method

1. **frame**: In-menory images generated by extract_video_keyframes method.

2. **file_name**:  File name pattern for the persisted image.

3. **file_path**: Folder location where files needs to be saved

4. **file_ext**: File extension indicating the file type for example - ‘.jpg’


.. code-block:: python

     vd.save_frame_to_disk(img, file_path=output_folder_video_image, \
          file_name="test_"+str(counter), file_ext=".jpeg")

Code below is a complete example for a single video file.

.. code-block:: python
   :emphasize-lines: 1,8,11,14,17-18,21-23,26-28
   :linenos:

   from Katna.video import Video
   import os
   
   # For windows, the below if condition is must.
   if __name__ == "__main__":

     #instantiate the video class
     vd = Video()

     #number of key-frame images to be extracted
     no_of_frames_to_return = 12

     #Input Video file path
     video_file_path = os.path.join(".", "tests","data", "pos_video.mp4")

     #Call the public key-frame extraction method
     imgs = vd.extract_video_keyframes(no_of_frames = no_of_frames_to_return, \
          file_path= video_file_path)

     # Make folder for saving frames
     output_folder_video_image = 'selectedframes'
     if not os.path.isdir(os.path.join(".", output_folder_video_image)):
          os.mkdir(os.path.join(".", output_folder_video_image))

     # Save all frames to disk
     for counter,img in enumerate(imgs):
          vd.save_frame_to_disk(img, file_path=output_folder_video_image, \
               file_name="test_"+str(counter), file_ext=".jpeg")


Extract keyframes for all videos in a directory
----------------------------------------------------------------

Call the **extract_keyframes_from_videos_dir** method.
The method accepts three parameters and writes the data using a Writer class object. Katna comes with a default
writer named "DiskWriterKeyFrame".

1. **no_of_frames**: Number of key frames to be extracted

2. **dir_path**: Directory path which has all the videos.

3. **writer**: Writer class object to process the keyframes for the file

.. code-block:: python

     diskwriter = DiskWriterKeyFrame(location="/path/to/output/folder")
     imgs = vd.extract_keyframes_from_videos_dir(no_of_frames = no_of_frames_to_return, \
     dir_path= dir_path_containing_videos, writer=diskwriter)


Code below is a complete example for a directory containing videos.

.. code-block:: python
   :emphasize-lines: 1,2,10,13,17,19,21-23
   :linenos:

   from Katna.video import Video
   from Katna.writer import DiskWriterKeyFrame
   import os
   import ntpath

   # For windows, the below if condition is must.
   if __name__ == "__main__":

     #instantiate the video class
     vd = Video()

     #number of key-frame images to be extracted
     no_of_frames_to_return = 3

     #Input Video directory path
     #All .mp4 and .mov files inside this directory will be used for keyframe extraction)
     videos_dir_path = os.path.join(".", "tests","data")

     diskwriter = DiskWriterKeyFrame(location="selectedframes")

     vd.extract_keyframes_from_videos_dir(
          no_of_frames=no_of_frames_to_return, dir_path=videos_dir_path,
          writer=diskwriter
     )


Users can add custom writers based on their need. To do this, extend the **Writer** class implemented
in Katna.writer. The custom writer needs to implement the **write** method, which receives the filepath
of the input file and the data generated by the Katna Library.

Below is one example where a custom writer is created which prints data instead of writing it
on disk :

.. code-block:: python

   from Katna.video import Video
   from Katna.writer import Writer
   import os
   import ntpath

   class PrintDataWriter(Writer):
     """Custom writer to print the data
    """

     def write(self, filepath, data):
     """The write method to process data generated by Katna Library
     """
          for counter, img in enumerate(data):
               print("Data for file: ", filepath, " is : ", data)

     
     #instantiate the video class
     vd = Video()

     #number of key-frame images to be extracted
     no_of_frames_to_return = 3

     #Input Video directory path
     #All .mp4 and .mov files inside this directory will be used for keyframe extraction)
     videos_dir_path = os.path.join(".", "tests","data")

     # initialize the print writer
     printwriter = PrintDataWriter()


     vd.extract_keyframes_from_videos_dir(
          no_of_frames=no_of_frames_to_return, dir_path=videos_dir_path,
          writer=printwriter
     )


Below is another example, where a custom disk writer is created to alter the filename of saved files:

.. code-block:: python

   from Katna.video import Video
   from Katna.writer import DiskWriterKeyFrame
   import os
   import ntpath

   class CustomDiskWriter(DiskWriterKeyFrame):
     """Custom disk writer to save filename differently

    :param DiskWriterKeyFrame: Writer class to overwrite
    :type DiskWriterKeyFrame: Writer
    """

     # This method is used to generate output filename for a keyframe
     # Here we call the super on te base class and add a suffix
     def generate_output_filename(self, filepath, keyframe_number):
        """Custom output filename method

        :param filepath: [description]
        :type filepath: [type]
        """
        filename = super().generate_output_filename(filepath, keyframe_number)

        suffix = "keyframe"

        return "_".join([filename, suffix])







Compress video using Katna
----------------------------------------------------------------

**Step 1**

Import the video module 

.. code-block:: python

   from Katna.video import Video

**Step 2**

Instantiate the video class inside your main module (necessary for multiprocessing in windows)

.. code-block:: python

     if __name__ == "__main__":
          vd = Video()
   
**Step 3**

Call the **compress_video** method.
The method accepts one required parameter that is path to input file returns status whether compression was done 
successfully or not. 
Refer to API reference for further details. Below are the parameters required by the method

1. **file_path**: Input video full file path. This is the only compulsory parameter


.. code-block:: python

     status = vd.compress_video(file_path= video_file_path)


**Step 4 (Optional)**

In case you play around with the different parameters like where to save compressed file etc.
you can change optional parameters in compress_video function.
Refer to API reference for further details. Below are the optional parameters supported by the method

1. **force_overwrite** (bool, optional) – optional parameter if True then if there \
is already a file in output file location function will overwrite it, defaults to False

2. **crf_parameter** (int, optional) – Constant Rate Factor Parameter for 
controlling amount of video compression to be applied, The range of the quantizer 
scale is 0-51: where 0 is lossless, 23 is default, and 51 is worst possible. 
It is recommend to keep this value between 20 to 30 A lower value is a higher quality, 
you can change default value by changing config.Video.video_compression_crf_parameter

3. **output_video_codec** (str, optional) – Type of video codec to choose, 
Currently supported options are libx264 and libx265, libx264 is default option. 
libx264 is more widely supported on different operating systems and platforms, 
libx265 uses more advanced x265 codec and results in better compression and even 
less output video sizes with same or better quality. Right now libx265 is not as 
widely compatible on older versions of MacOS and Widows by default. 
If wider video compatibility is your goal you should use libx264., 
you can change default value by changing Katna.config.Video.video_compression_codec

4. **out_dir_path** (str, optional) – output folder path where you want output 
video to be saved, defaults to “”

5. **out_file_name** (str, optional) – output filename, if not mentioned it will 
be same as input filename, defaults to “”


.. code-block:: python

     vd.compress_video(file_path, force_overwrite=False, \
     crf_parameter=23, output_video_codec='libx264', out_dir_path='', out_file_name='')

Code below is a complete example for a single video file.

.. code-block:: python
   :emphasize-lines: 2,6,19-22
   :linenos:

     import os
     from Katna.video import Video

     def main():

          vd = Video()

          # folder to save extracted images
          output_folder_for_compressed_videos= "compressed_folder"
          out_dir_path = os.path.join(".", output_folder_for_compressed_videos)

          if not os.path.isdir(out_dir_path):
               os.mkdir(out_dir_path)

          # Video file path
          video_file_path = os.path.join(".", "tests", "data", "pos_video.mp4")
          print(f"Input video file path = {video_file_path}")

          status = vd.compress_video(
               file_path=video_file_path,
               out_dir_path=out_dir_path
          )


     if __name__ == "__main__":
          main()



Compress all videos in folder using Katna
----------------------------------------------------------------

**Step 1**

Import the video module 

.. code-block:: python

   from Katna.video import Video

**Step 2**

Instantiate the video class inside your main module (necessary for multiprocessing in windows)

.. code-block:: python

     if __name__ == "__main__":
          vd = Video()
   
**Step 3**

Call the **compress_videos_from_dir** method.
The method accepts one required parameter that is path to input folder where
videos needs to be picked for compression returns status whether compression was done 
successfully or not. 
Refer to API reference for further details. Below are the parameters required by the method

1. **dir_path**: Input videos full folder path. This is the only compulsory parameter


.. code-block:: python

     status = vd.compress_videos_from_dir(dir_path=input_video_folder_path)


**Step 4 (Optional)**

In case you play around with the different parameters like where to save compressed file etc.
you can change optional parameters in compress_video function.
Refer to API reference for further details. Below are the optional parameters supported by the method

1. **force_overwrite** (bool, optional) – optional parameter if True then if there \
is already a file in output file location function will overwrite it, defaults to False

2. **crf_parameter** (int, optional) – Constant Rate Factor Parameter for 
controlling amount of video compression to be applied, The range of the quantizer 
scale is 0-51: where 0 is lossless, 23 is default, and 51 is worst possible. 
It is recommend to keep this value between 20 to 30 A lower value is a higher quality, 
you can change default value by changing config.Video.video_compression_crf_parameter

3. **output_video_codec** (str, optional) – Type of video codec to choose, 
Currently supported options are libx264 and libx265, libx264 is default option. 
libx264 is more widely supported on different operating systems and platforms, 
libx265 uses more advanced x265 codec and results in better compression and even 
less output video sizes with same or better quality. Right now libx265 is not as 
widely compatible on older versions of MacOS and Widows by default. 
If wider video compatibility is your goal you should use libx264., 
you can change default value by changing Katna.config.Video.video_compression_codec

4. **out_dir_path** (str, optional) – output folder path where you want output 
video to be saved, defaults to “”


.. code-block:: python

     vd.compress_videos_from_dir(dir_path, force_overwrite=False, \
     crf_parameter=23, output_video_codec='libx264', out_dir_path='')

Code below is a complete example for a single video file.

.. code-block:: python
   :emphasize-lines: 2,6,19-22
   :linenos:

     import os
     from Katna.video import Video

     def main():

          vd = Video()

          # folder to save extracted images
          output_folder_for_compressed_videos= "compressed_folder"
          out_dir_path = os.path.join(".", output_folder_for_compressed_videos)

          if not os.path.isdir(out_dir_path):
               os.mkdir(out_dir_path)

          # Video file path
          video_folder_path = os.path.join(".", "tests", "data")
          print(f"Input video folder path = {video_folder_path}")

          status = vd.compress_videos_from_dir(
               dir_path=video_folder_path,
               out_dir_path=out_dir_path
          )


     if __name__ == "__main__":
          main()



.. _tutorials_video_smart_resize:

Smart video resize using katna
----------------------------------------------------------------


Please note that is it necessary to first install and initialize
Google mediapipe autoflip solution before using Katna video 
resize (experimental) feature.

Install Google Mediapipe library and Autoflip solution. 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. Install Mediapipe by following these instructions `here <https://google.github.io/mediapipe/getting_started/install>`_.
     
2. Build Autoflip c++ solution by following these instructions `from here <https://google.github.io/mediapipe/solutions/autoflip>`_.



Resize a single video using Katna (Using Experimental Mediapipe Autoflip bridge)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Step 1**

Import the video module 

.. code-block:: python

     from Katna.video import Video

**Step 2**

Instantiate the video class inside your main module (necessary for multiprocessing in windows)

.. code-block:: python

     autoflip_build_path = "/absolute/path/to/autoflip/build/folder
     autoflip_model_path = "/absolute/path/to/autoflip/model/folder

     if __name__ == "__main__":
          vd = Video(autoflip_build_path, autoflip_model_path)

**Step 3 (Optional)**

Configure the mediapipe autoflip properties. To check the list of configurable options, check :ref:`Katna.video_resize`. 

.. code-block:: python

     import Katna.config as app_config

     # get the current configuration
     conf = app_config.MediaPipe.AutoFlip.get_conf()

     # set True for features which are required in output video
     conf["ENFORCE_FEATURES"] = {
          "FACE_CORE_LANDMARKS": False,
          "FACE_ALL_LANDMARKS": False,
          "FACE_FULL": False,
          "HUMAN": False,
          "PET": False,
          "CAR": False,
          "OBJECT": False
     }

     # % stabalization threshold
     conf["STABALIZATION_THRESHOLD"] = 0.5

     # opacity of blur area
     conf["BLUR_AREA_OPACITY"] = 0.6

     # update configuration
     app_config.MediaPipe.AutoFlip.set_conf(conf)

     
**Step 4**

Call the **resize_video** method.
The method accepts three parameters and returns a status whether video resize is
performed successfully or not. 
Refer to API reference for further details. Below are the four parameters required by the method


1. **file_path**: Video file path.

2. **abs_file_path_output**: absolute path for saving final output file.

3. **aspect_ratio**: required aspect ratio for output video. e.g. "4:3"


.. code-block:: python

     vd.resize_video(file_path = file_path, abs_file_path_output = abs_file_path_output, aspect_ratio = aspect_ratio)


Code below is a complete example for a single video file.

.. code-block:: python
     :emphasize-lines: 1,8,11,19-20,22-25
     :linenos:

     from Katna.video import Video
     import os
     
     # For windows, the below if condition is must.
     if __name__ == "__main__":

          # set the autoflip build and model path directory based on your installation
          # usually autoflip build is located here : /mediapipe/repo/bazel-build/mediapipe/examples/desktop/autoflip
          # usually mediapipe model is located here : /mediapipe/repo/mediapipe/models
          autoflip_build_path = "/absolute/path/to/autoflip/build/folder
          autoflip_model_path = "/absolute/path/to/autoflip/model/folder

          # desired aspect ratio (e.g potrait mode - 9:16)
          aspect_ratio = 9:16

          # input video file path
          file_path = os.path.join(".", "tests", "data", "pos_video.mp4")

          # output file to save resized video
          abs_file_path_output = os.path.join(".", "tests", "data", "pos_video_resize.mp4")

          #instantiate the video class
          vd = Video(autoflip_build_path, autoflip_model_path)
          
          print(f"Input video file path = {file_path}")

          vd.resize_video(file_path = file_path, abs_file_path_output = abs_file_path_output, aspect_ratio = aspect_ratio)

          print(f"output resized video file path = {abs_file_path_output}")


**NOTE : In case of subprocess.CalledProcessError, try running the resize_video method again.**


Resize multiple videos in a directory using Katna (Using Experimental Mediapipe Autoflip bridge)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Call the **resize_video_from_dir** method.
The method accepts three parameters and returns a status whether video resize is
performed successfully or not. 
Refer to API reference for further details. Below are the four parameters required by the method


1. **dir_path**: Directory path where videos are stored.

2. **abs_dir_path_output**: absolute path to directory where resized videos will be dumped.

3. **aspect_ratio**: required aspect ratio for output video. e.g. "4:3"


.. code-block:: python

     vd.resize_video_from_dir(dir_path = dir_path, abs_dir_path_output = abs_dir_path_output, aspect_ratio = aspect_ratio)


Code below is a complete example for a folder full of video file.

.. code-block:: python
     :emphasize-lines: 1,8,11,18
     :linenos:

     from Katna.video import Video
     import os
     
     # For windows, the below if condition is must.
     if __name__ == "__main__":

          # folder where videos are located
          dir_path = file_path = os.path.join(".", "tests", "data")

          # output folder to dump videos after resizing
          abs_dir_path_output = os.path.join(".", "tests", "data", "resize_results")

          # intialize video class
          vd = Video(autoflip_build_path, autoflip_model_path)

          # invoke resize for directory
          try:
               vd.resize_video_from_dir(dir_path = dir_path, abs_dir_path_output = abs_dir_path_output, aspect_ratio = aspect_ratio)
          except Exception as e:
               raise e
          
          print(f"output resized video dir path = {abs_dir_path_output}")

